<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<title>Fortegnsskjema</title>

<!-- MathJax -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
body { 
  font-family: system-ui, sans-serif; 
  margin: 40px; 
}

/* x-akse */
.axis {
  position: relative;
  height: 60px;
  border-top: 2px solid black;
  margin-bottom: 50px;
}

/* rotetikett */
.root-label {
  position: absolute;
  top: -35px;
  font-size: 18px;
  transform: translateX(-50%);
  font-family: serif;
}

/* faktorlinje */
.factor-line {
  position: relative;
  height: 40px;
  margin-bottom: 25px;
}

.factor-name {
  position: absolute;
  left: 0px;
  top: -10px;
  font-size: 18px;
  font-family: serif;
  white-space: nowrap;
}
.factor-seg {
  position: absolute;
  top: 0px;
  height: 0;
  border-top-width: 3px;
}

.posSeg { border-top-style: solid; border-color: black; }
.negSeg { border-top-style: dashed; border-color: black; }

/* 0-symbol */
.zero-symbol {
  position: absolute;
  top: -10px;
  transform: translateX(-50%);
  font-size: 18px;
  font-family: serif;

  background: white;      /* hvitt felt bak null-symbol */
  padding: 0 1px;         /* litt luft på sidene */
  z-index: 999;           /* alltid foran vertikale linjer */
}

/* Flytt diagrammet til høyre */
.axis,
.factor-line {
  margin-left: 200px;
}

/* Polynomnavn skal stå der de står */
.factor-name {
  margin-left: -200px;
}

/* Luft mellom inputfelt og skjema */
#scheme-wrapper {
  margin-top: 40px;
}

/* Vertikale linjesegmenter */
.vline-seg {
  position: absolute;
  width: 2px;
  background: black;
  left: 0;   /* flyttes i JS */
}

/* Viktig for absolutte barn i #scheme (vline-seg, mm.) */
#scheme {
  position: relative;
}

/* Lagrekkefølge: faktor-segmenter < vertikale linjer < 0-symbol */
.factor-seg { z-index: 1; }
.vline-seg  { z-index: 2; }
.zero-symbol { z-index: 3; }

.stopper {
  position: absolute;
  background: white;
  width: 100%;
  height: 20px;
  z-index: 900;
}

#bottom-mask {
  position: absolute;
  left: 0;
  width: 100%;
  height: 60px;
  background: white;
  z-index: 50;
  pointer-events: none;
}
#red-box {
  position: absolute;
  left: 0;
  width: 100%;
  height: 100px;
  background: white;
  z-index: 50;
  pointer-events: none;
}
</style>
</head>

<body>

<h2>Fortegnsskjema</h2>

<label for="inputPoly">Skriv inn polynom som faktorisert uttrykk:</label><br>
<input id="inputPoly" type="text" style="width:400px; font-size:16px;"
       placeholder="f.eks. -2(x+1/2)(x-2)">
<button id="genBtn" type="button">Lag fortegnsskjema</button>

<div id="scheme-wrapper">
  <div id="scheme"></div>
</div>

<script>
/* ========= Tall → brøk (MathJax) ========= */
function toFraction(x, tol = 1e-10) {
  const k_pi = x / Math.PI;
  if (Math.abs(k_pi - Math.round(k_pi)) < tol) {
    const k = Math.round(k_pi);
    if (k === 1) return "\\pi";
    if (k === -1) return "-\\pi";
    return `${k}\\pi`;
  }
  const k_e = x / Math.E;
  if (Math.abs(k_e - Math.round(k_e)) < tol) {
    const k = Math.round(k_e);
    if (k === 1) return "e";
    if (k === -1) return "-e";
    return `${k}e`;
  }
  if (Math.abs(x - Math.round(x)) < tol) {
    return Math.round(x).toString();
  }

  let sign = x < 0 ? "-" : "";
  x = Math.abs(x);

  let h1 = 1, h2 = 0;
  let k1 = 0, k2 = 1;
  let b = x;

  while (true) {
    const a = Math.floor(b);
    const h = a * h1 + h2;
    const k = a * k1 + k2;
    if (Math.abs(x - h/k) < tol) {
      return `${sign}\\frac{${h}}{${k}}`;
    }
    h2 = h1; h1 = h;
    k2 = k1; k1 = k;
    b = 1 / (b - a);
  }
}

function parseNumber(str) {
  if (!str) return NaN;
  str = String(str).replace(/,/g, ".");
  str = str
    .replace(/π/gi, Math.PI)
    .replace(/pi/gi, Math.PI)
    .replace(/\be\b/g, Math.E);

  if (str.includes("/")) {
    const [numStr, denStr] = str.split("/");
    const num = parseNumber(numStr);
    const den = parseNumber(denStr);
    if (!isFinite(num) || !isFinite(den) || den === 0) return NaN;
    return num / den;
  }

  const v = Number(str);
  return isFinite(v) ? v : NaN;
}

/* ========= PARSE LINEÆRE FAKTORER ========= */
function parseLinearFactor(str) {
  const num = '(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)';
  const sym = '(?:π|pi|e)';
  const atom = `(?:${sym}|${num})`;
  const frac = `(?:${atom}\\/${atom}|${atom})`;
  const signed = `[+-]?(?:${frac})`;

  const re = new RegExp(`^(${signed})?x(${signed})?$`, 'i');
  const m = str.match(re);
  if (!m) return null;

  let aRaw = m[1];
  let bRaw = m[2];

  let a;
  if (aRaw == null || aRaw === "" || aRaw === "+") a = 1;
  else if (aRaw === "-") a = -1;
  else a = parseNumber(aRaw);

  let b = 0;
  if (bRaw != null && bRaw !== "") b = parseNumber(bRaw);

  if (!isFinite(a) || a === 0) return null;
  if (!isFinite(b)) return null;

  return -b / a;
}

/* ========= PARSE POLYNOM MED LEDENDE KONSTANT ========= */
// Tolk "-2(x+1/2)(x-2)" osv.
function parsePolynomial(expr) {
  expr = expr.replace(/\s+/g, "").replace(/,/g, ".");
  const result = [];

  // 1) Ledende konstant (heltall eller brøk), f.eks. -2 eller 3/4
  const c = expr.match(/^([+-]?(?:\d+(?:\.\d+)?|\d*\/\d+))(?!x)/);
  if (c) {
    const val = parseNumber(c[1]);
    if (isFinite(val) && val !== 0) {
      result.push({
        root: null,          // ikke en rot
        mult: 1,
        label: c[1],         // vis tallet i margen
        constant: val        // brukes for fortegn og produktlinje
      });
    }
    expr = expr.slice(c[1].length);
  }

  // 2) Parentes-faktorer (lineære)
  const matches = [...expr.matchAll(/\((.*?)\)(\^\d+)?/g)];
  matches.forEach(m => {
    const inside = m[1];
    const pow = m[2] ? Number(m[2].slice(1)) : 1;
    const root = parseLinearFactor(inside);
    if (root !== null) {
      result.push({ root, mult: pow, label: inside, constant: null });
    }
  });

  return result;
}

/* ========= MATEMATIKK FOR FORTEGNSSKJEMA ========= */
function buildIntervals(roots) {
  const R = [...new Set(roots)].sort((a,b)=>a-b);
  const out = [];

  if (R.length === 0)
    return [{left:-1, right:1, sample:0}];

  out.push({ left:R[0]-2, right:R[0], sample:R[0]-1 });

  for (let i=0; i<R.length-1; i++)
    out.push({
      left:R[i],
      right:R[i+1],
      sample:(R[i] + R[i+1])/2
    });

  out.push({
    left:R[R.length-1],
    right:R[R.length-1]+2,
    sample:R[R.length-1]+1
  });

  return out;
}

function signFactor(x, root, mult) {
  if (Math.abs(x-root) < 1e-12) return 0;
  const s = Math.sign(x-root);
  return mult % 2 === 0 ? 1 : s;
}

/* ========= BYGG SELVE SKJEMAET ========= */
function buildScheme(factors) {
  const container = document.getElementById("scheme");
  container.innerHTML = "";

  // Viktig: filtrer bort null/undefined (f.eks. fra konstantfaktoren)
  const allRoots =
    [...new Set(factors.flatMap(f => f.roots))]
      .filter(r => r !== null && r !== undefined)
      .sort((a,b)=>a-b);

  const axis = document.createElement("div");
  axis.className = "axis";
  container.appendChild(axis);

  const W = 600;
  const x0 = 80;

  const minX = (allRoots.length ? allRoots[0] : -1) - 2;
  const maxX = (allRoots.length ? allRoots[allRoots.length-1] : 1) + 2;

  const pos = x => x0 + (x-minX)/(maxX-minX)*(W-x0);

  // tegn røtter (KUN etiketter + usynlig mark)
  allRoots.forEach(r => {
    const lbl = document.createElement("div");
    lbl.className = "root-label";
    lbl.dataset.root = r;
    lbl.innerHTML = `\\(${toFraction(r)}\\)`;
    lbl.style.left = pos(r) + "px";
    axis.appendChild(lbl);

    const mark = document.createElement("div");
    mark.className = "root-mark";
    mark.dataset.root = r;
    mark.style.position = "absolute";
    mark.style.left = pos(r) + "px";
    mark.style.top = "0px";
    mark.style.width = "1px";
    mark.style.height = "1px";
    axis.appendChild(mark);
  });

  const intervals = buildIntervals(allRoots);
  const lines = [];

  // faktorlinjer
  factors.forEach(f => {
    const line = document.createElement("div");
    line.className = "factor-line";

    const name = document.createElement("div");
    name.className = "factor-name";
    name.innerHTML = `\\(${f.label}\\)`;
    line.appendChild(name);

    line._name = name;
    line._roots = f.roots;
    line._constant = f.constant ?? null;
    line._isProduct = !!f.isProduct;

    lines.push(line);
    container.appendChild(line);
  });

  /* --- HJELPER: tegn vertikale linjer med hull rundt 0-symbolene --- */
  function drawVerticalLines(allRoots, container, pos) {
    container.querySelectorAll(".vline-seg").forEach(e => e.remove());

    const contRect = container.getBoundingClientRect();
    const axis = container.querySelector(".axis");
    const startY = axis.offsetTop - 5;

    const totalHeight = container.offsetHeight;

    const zeros = [...container.querySelectorAll(".zero-symbol")].map(z => {
      const zr = z.getBoundingClientRect();
      return {
        top: zr.top - contRect.top - 4,
        bottom: zr.bottom - contRect.top + 4
      };
    });

    allRoots.forEach(r => {
      const mark = container.querySelector(`.root-mark[data-root="${r}"]`);
      const mr = mark.getBoundingClientRect();
      const x = mr.left - contRect.left;

      let segments = [{ top: startY, bottom: totalHeight }];

      zeros.forEach(z => {
        const gapTop = z.top;
        const gapBottom = z.bottom;
        const newSegs = [];

        segments.forEach(seg => {
          if (seg.top < gapTop)
            newSegs.push({ top: seg.top, bottom: gapTop });

          if (seg.bottom > gapBottom)
            newSegs.push({ top: gapBottom, bottom: seg.bottom });
        });

        segments = newSegs;
      });

      segments.forEach(seg => {
        if (seg.bottom <= seg.top) return;
        const div = document.createElement("div");
        div.className = "vline-seg";
        div.style.left = x + "px";
        div.style.top = seg.top + "px";
        div.style.height = (seg.bottom - seg.top) + "px";
        container.appendChild(div);
      });
    });
  }

  // --- Vent til MathJax og layout er klar ---
  MathJax.typesetPromise().then(() => {

    // 1) auto padding for margen
    lines.forEach(line => {
      const w = line._name.offsetWidth;
      line.style.paddingLeft = (w + 30) + "px";
    });

    // 2) segmenter for hver linje (+ nullsymboler der det finnes røtter)
    lines.forEach((line, idx) => {
      const f = factors[idx];

      // === KONSTANT-FAKTOR LINJE ===
      if (line._constant !== null && line._constant !== undefined && !line._isProduct) {
        const ints = buildIntervals(allRoots);
        ints.forEach(I => {
          const seg = document.createElement("div");
          seg.className = "factor-seg " + (line._constant > 0 ? "posSeg" : "negSeg");
          const leftPos = pos(I.left);
          const rightPos = pos(I.right);
          seg.style.left = leftPos + "px";
          seg.style.width = (rightPos - leftPos) + "px";
          line.appendChild(seg);
        });
        return; // hopp over videre (ingen 0-symboler for konstanten)
      }

      // === VANLIG FAKTOR: tegn 0-symboler ved røttene ===
      f.roots.forEach(r => {
        const z = document.createElement("div");
        z.className = "zero-symbol";
        z.textContent = "0";
        z.style.left = pos(r) + "px";
        line.appendChild(z);
      });

      const ints = buildIntervals(allRoots);

      ints.forEach(I => {
        // Startverdi for produktlinje skal ta med konstantens fortegn.
        // Alle andre linjer starter på 1.
        let s = (line._isProduct ? (line._constant ?? 1) : 1);

        for (let i=0; i<f.roots.length; i++)
          s *= signFactor(I.sample, f.roots[i], f.mult[i]);

        const seg = document.createElement("div");
        seg.className = "factor-seg " + (s > 0 ? "posSeg" : "negSeg");

        const pad = 6;  // luft rundt 0 ved EGEN faktor sine røtter

        let leftPos  = pos(I.left);
        let rightPos = pos(I.right);

        function isFactorRoot(x) {
          return f.roots.some(r => Math.abs(r - x) < 1e-9);
        }

        if (isFactorRoot(I.left))  leftPos  += pad;
        if (isFactorRoot(I.right)) rightPos -= pad;

        seg.style.left  = leftPos + "px";
        seg.style.width = (rightPos - leftPos) + "px";

        line.appendChild(seg);
      });
    });

    // --- hvit stopper under produktlinja ---
    const productLine = container.querySelector(".factor-line:last-child");

    // --- automatisk rød boks under produktlinja ---
    let red = container.querySelector("#red-box");
    if (!red) {
      red = document.createElement("div");
      red.id = "red-box";
      container.appendChild(red);
    }
    const offset = -25;
    red.style.top = (productLine.offsetTop + productLine.offsetHeight + offset) + "px";

    const stopper = document.createElement("div");
    stopper.className = "stopper";
    const y = productLine.offsetTop + productLine.offsetHeight + 5;
    stopper.style.top = y + "px";
    container.appendChild(stopper);

    let mask = container.querySelector("#bottom-mask");
    if (!mask) {
      mask = document.createElement("div");
      mask.id = "bottom-mask";
      container.appendChild(mask);
    }
    mask.style.top = (productLine.offsetTop + productLine.offsetHeight + 5) + "px";

    // 3) TEGN VERTIKALE LINJER TIL SLUTT (én gang)
    drawVerticalLines(allRoots, container, pos);
  }); // slutt MathJax
} // slutt buildScheme

// =============================
// GENERER FRA INPUT
// =============================
function generateFromInput() {
  const txt = document.getElementById("inputPoly").value;
  if (!txt) return;

  const parsed = parsePolynomial(txt);
  if (parsed.length === 0) {
    alert("Kunne ikke tolke polynomet. Pass på at du skriver det faktorisert, f.eks (x-2)(2x+1) eller med ledende konstant som -2(x+1/2)(x-2).");
    return;
  }

  // Egne linjer for alle faktorer, inkl. konstantfaktoren om den finnes
  const factors = parsed.map(f => {
    if (f.root === null) {
      return {
        label: f.label,
        roots: [],         // ingen røtter for konstant
        mult: [],
        constant: f.constant,
        isProduct: false
      };
    }
    return {
      label: f.label,
      roots: [f.root],
      mult: [f.mult],
      constant: null,
      isProduct: false
    };
  });

  // Produktlinjen nederst:
  const constantFactor = parsed.find(f => f.root === null);
  factors.push({
    label: txt,
    roots: parsed
      .filter(f => f.root !== null && f.root !== undefined)
      .map(f => f.root),
    mult: parsed
      .filter(f => f.root !== null && f.root !== undefined)
      .map(f => f.mult),
    constant: constantFactor ? Math.sign(constantFactor.constant) : 1, // bare fortegn!
    isProduct: true
  });

  buildScheme(factors);
}

// =============================
// EVENT-LISTENER + startverdi
// =============================
document.getElementById("genBtn").addEventListener("click", generateFromInput);
document.getElementById("inputPoly").value = "-2(x+1/2)(x-2)";
generateFromInput();
</script>

</body>
</html>