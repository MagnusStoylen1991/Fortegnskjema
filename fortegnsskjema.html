
<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<title>Fortegnsskjema</title>

<!-- MathJax -->
<script>
  window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
body { 
  font-family: system-ui, sans-serif; 
  margin: 40px; 
}

/* x-akse */
.axis {
  position: relative;
  height: 60px;
  border-top: 2px solid black;
  margin-bottom: 50px;
}

/* vertikal rotstrek */
.root-line {
  position: absolute;
  top: -10px;
  width: 2px;
  height: 70px;
  background: black;
  transform: translateX(-50%);
}

/* rotetikett */
.root-label {
  position: absolute;
  top: -35px;
  font-size: 18px;
  transform: translateX(-50%);
  font-family: serif;
}

/* faktorlinje */
.factor-line {
  position: relative;
  height: 40px;
  margin-bottom: 25px;
}

.factor-name {
  position: absolute;
  left: 0px;
  top: -10px;
  font-size: 18px;
  font-family: serif;
  white-space: nowrap;
}
.factor-seg {
  position: absolute;
  top: 0px;
  height: 0;
  border-top-width: 3px;
}

.posSeg { border-top-style: solid; border-color: black; }
.negSeg { border-top-style: dashed; border-color: black; }

/* 0-symbol */
.zero-symbol {
  position: absolute;
  top: -10px;
  transform: translateX(-50%);
  font-size: 18px;
  font-family: serif;
}

/* Flytt diagrammet til høyre */
.axis,
.factor-line {
  margin-left: 200px;
}

/* Polynomnavn skal stå der de står */
.factor-name {
  margin-left: -200px;
}

/* Luft mellom inputfelt og skjema */
#scheme-wrapper {
  margin-top: 40px;
}

/* Vertikale linjesegmenter */
.vline-seg {
  position: absolute;
  width: 2px;
  background: black;
  left: 0;   /* flyttes i JS */
}

/* Viktig for absolutte barn i #scheme (vline-seg, mm.) */
#scheme {
  position: relative;
}

/* Lagrekkefølge: faktor-segmenter < vertikale linjer < 0-symbol */
.factor-seg { z-index: 1; }
.vline-seg  { z-index: 2; }
.zero-symbol { z-index: 3; }


.zero-symbol {
  position: absolute;
  top: -10px;
  transform: translateX(-50%);
  font-size: 18px;
  font-family: serif;

  background: white;      /* ⭐ hvitt felt bak null-symbol */
  padding: 0 1px;         /* ⭐ litt luft på sidene */
  z-index: 999;           /* ⭐ alltid foran vertikale linjer */
}

.stopper {
  position: absolute;
  background: white;
  width: 100%;    /* dekker hele skjemaets bredde */
  height: 20px;   /* litt høyde for å kutte linja */
  z-index: 900;   /* over linjene, men under null-symbolene */
}

#bottom-mask {
  position: absolute;
  left: 0;
  width: 100%;
  height: 60px;           /* hvor mye av de nederste linjene som skjules */
  background: white;
  z-index: 50;            /* foran vertikale linjer (z-index 2), men bak alt annet */
  pointer-events: none;   /* ikke blokker klikk */
}
#red-box {
  position: absolute;   /* viktig! følger containeren */
  left: 0;
  width: 100%;
  height: 100px;
  background: white;
  z-index: 50;          /* foran linjer, bak symboler */
  pointer-events: none; /* ikke klikkbar */
}


</style>
</head>

<body>

<h2>Fortegnsskjema</h2>

<label for="inputPoly">Skriv inn polynom som faktorisert uttrykk:</label><br>
<input id="inputPoly" type="text" style="width:400px; font-size:16px;"
       placeholder="f.eks. (2x+1)(x-2)(x+3)">
<button id="genBtn" type="button">Lag fortegnsskjema</button>

<div id="scheme-wrapper">
  <div id="scheme"></div>
</div>
<!---<div id="red-box"></div>--->

<!-- JS legges til i DEL 3 og DEL 4 -->

<script>
/* ========= Tall → brøk (MathJax) ========= */
function toFraction(x, tol = 1e-10) {
  // gjenkjenn pi-multipler
  const k_pi = x / Math.PI;
  if (Math.abs(k_pi - Math.round(k_pi)) < tol) {
    const k = Math.round(k_pi);
    if (k === 1) return "\\pi";
    if (k === -1) return "-\\pi";
    return `${k}\\pi`;
  }

  // gjenkjenn e-multipler
  const k_e = x / Math.E;
  if (Math.abs(k_e - Math.round(k_e)) < tol) {
    const k = Math.round(k_e);
    if (k === 1) return "e";
    if (k === -1) return "-e";
    return `${k}e`;
  }

  // fallback: vanlige brøker
  if (Math.abs(x - Math.round(x)) < tol) {
    return Math.round(x).toString();
  }

  // rasjonale tall → brøk
  let sign = x < 0 ? "-" : "";
  x = Math.abs(x);

  let h1 = 1, h2 = 0;
  let k1 = 0, k2 = 1;
  let b = x;

  while (true) {
    const a = Math.floor(b);
    const h = a * h1 + h2;
    const k = a * k1 + k2;
    if (Math.abs(x - h/k) < tol) {
      return `${sign}\\frac{${h}}{${k}}`;
    }
    h2 = h1; h1 = h;
    k2 = k1; k1 = k;
    b = 1 / (b - a);
  }
}



function parseNumber(str) {
  if (!str) return NaN;

  // normaliser tekst (komma -> punktum)
  str = String(str).replace(/,/g, ".");

  // erstatt symboler
  str = str
    .replace(/π/g, Math.PI)
    .replace(/pi/gi, Math.PI)
    .replace(/\be\b/g, Math.E);   // e som eget symbol, ikke del av "5e3"

  // håndter brøk: a/b
  if (str.includes("/")) {
    const [numStr, denStr] = str.split("/");
    const num = parseNumber(numStr);
    const den = parseNumber(denStr);
    if (!isFinite(num) || !isFinite(den) || den === 0) return NaN;
    return num / den;
  }

  const v = Number(str);
  return isFinite(v) ? v : NaN;
}

/* ========= PARSE LINEÆRE FAKTORER ========= */
// Tolk "2x+1"
function parseLinearFactor(str) {
  // tall/brøk/symbol-mønster
  const num = '(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)';
  const sym = '(?:π|pi|e)';
  const atom = `(?:${sym}|${num})`;
  const frac = `(?:${atom}\\/${atom}|${atom})`;
  const signed = `[+-]?(?:${frac})`;

  const re = new RegExp(`^(${signed})?x(${signed})?$`, 'i');
  const m = str.match(re);
  if (!m) return null;

  let aRaw = m[1];
  let bRaw = m[2];

  // manglende koeffisient
  let a;
  if (aRaw == null || aRaw === "" || aRaw === "+") a = 1;
  else if (aRaw === "-") a = -1;
  else a = parseNumber(aRaw);

  let b = 0;
  if (bRaw != null && bRaw !== "") b = parseNumber(bRaw);

  if (!isFinite(a) || a === 0) return null;
  if (!isFinite(b)) return null;

  return -b / a;
}

// Tolk "(2x+1)(x-3)^2(x+4)"
function parsePolynomial(expr) {
 // fjern mellomrom og konverter norsk komma til punktum
expr = expr.replace(/\s+/g, "").replace(/,/g, ".");

  const matches = [...expr.matchAll(/\((.*?)\)(\^\d+)?/g)];
  const result = [];

  matches.forEach(m => {
    const inside = m[1];
    const pow = m[2] ? Number(m[2].slice(1)) : 1;
    const root = parseLinearFactor(inside);
    if (root !== null) {
      result.push({ root, mult: pow, label: inside });
    }
  });

  return result;
}

/* ========= MATEMATIKK FOR FORTEGNSSKJEMA ========= */
function buildIntervals(roots) {
  const R = [...new Set(roots)].sort((a,b)=>a-b);
  const out = [];

  if (R.length === 0)
    return [{left:-1, right:1, sample:0}];

  out.push({ left:R[0]-2, right:R[0], sample:R[0]-1 });

  for (let i=0; i<R.length-1; i++)
    out.push({
      left:R[i],
      right:R[i+1],
      sample:(R[i] + R[i+1])/2
    });

  out.push({
    left:R[R.length-1],
    right:R[R.length-1]+2,
    sample:R[R.length-1]+1
  });

  return out;
}

function signFactor(x, root, mult) {
  if (Math.abs(x-root) < 1e-12) return 0;
  const s = Math.sign(x-root);
  return mult % 2 === 0 ? 1 : s;
}

/* ========= BYGG SELVE SKJEMAET ========= */
function buildScheme(factors) {
  const container = document.getElementById("scheme");
  container.innerHTML = "";

  const allRoots = [...new Set(factors.flatMap(f => f.roots))].sort((a,b)=>a-b);

  const axis = document.createElement("div");
  axis.className = "axis";
  container.appendChild(axis);

  const W = 600;
  const x0 = 80;

  const minX = allRoots[0] - 2;
  const maxX = allRoots[allRoots.length-1] + 2;

  const pos = x => x0 + (x-minX)/(maxX-minX)*(W-x0);

  // tegn røtter (KUN etiketter, ikke korte vertikaler)
  allRoots.forEach(r => {
const lbl = document.createElement("div");
lbl.className = "root-label";
lbl.dataset.root = r;       // ⭐ NY LINJE – identifiserer roten
lbl.innerHTML = `\\(${toFraction(r)}\\)`;
lbl.style.left = pos(r) + "px";
axis.appendChild(lbl);

const mark = document.createElement("div");
mark.className = "root-mark";
mark.dataset.root = r;
mark.style.position = "absolute";
mark.style.left = pos(r) + "px";   // eksakt rotposisjon, uten transform!
mark.style.top = "0px";
mark.style.width = "1px";
mark.style.height = "1px";
axis.appendChild(mark);
  });

  const intervals = buildIntervals(allRoots);
  const lines = [];

  // faktorlinjer
  factors.forEach(f => {
    const line = document.createElement("div");
    line.className = "factor-line";

    const name = document.createElement("div");
    name.className = "factor-name";
    name.innerHTML = `\\(${f.label}\\)`;
    line.appendChild(name);

    line._name = name;
    line._roots = f.roots;
    lines.push(line);

    container.appendChild(line);
  });

  /* --- HJELPER: tegn vertikale linjer med hull rundt 0-symbolene --- */
function drawVerticalLines(allRoots, container, pos) {

  // Fjern gamle linjer
  container.querySelectorAll(".vline-seg").forEach(e => e.remove());

  // Containerens plassering i viewport
  const contRect = container.getBoundingClientRect();

  // Hvor x-aksen ligger høydemessig
  const axis = container.querySelector(".axis");
  const axisRect = axis.getBoundingClientRect();
 const startY = axis.offsetTop - 5;   // hopp opp 5px over horisontal linje

  // Hele skjemaets høyde
  const totalHeight = container.offsetHeight;

  // Nullsymboler – VI BRUKER KUN DERES Y-VERDIER
  const zeros = [...container.querySelectorAll(".zero-symbol")].map(z => {
    const zr = z.getBoundingClientRect();
    return {
      top: zr.top - contRect.top - 4,      // litt ekstra luft
      bottom: zr.bottom - contRect.top + 4
    };
  });

  // For hver rot:
  allRoots.forEach(r => {

    // Finn rotens eksakte X (via root-mark)
    const mark = container.querySelector(`.root-mark[data-root="${r}"]`);
    const mr = mark.getBoundingClientRect();
    const x = mr.left - contRect.left;

    // Start med ett stort segment
    let segments = [{ top: startY, bottom: totalHeight }];

    // Klipp hull basert på 0-symbolets Y-intervall
    zeros.forEach(z => {

      const gapTop = z.top;
      const gapBottom = z.bottom;

      const newSegs = [];

      segments.forEach(seg => {
        if (seg.top < gapTop)
          newSegs.push({ top: seg.top, bottom: gapTop });

        if (seg.bottom > gapBottom)
          newSegs.push({ top: gapBottom, bottom: seg.bottom });
      });

      segments = newSegs;
    });

    // Tegn segmenter
    segments.forEach(seg => {
      if (seg.bottom <= seg.top) return;

      const div = document.createElement("div");
      div.className = "vline-seg";
      div.style.left = x + "px";
      div.style.top = seg.top + "px";
      div.style.height = (seg.bottom - seg.top) + "px";
      container.appendChild(div);
    });
  });
}



  // --- Vent til MathJax og layout er klar ---
  MathJax.typesetPromise().then(() => {

    // 1) auto padding
    lines.forEach(line => {
      const w = line._name.offsetWidth;
      line.style.paddingLeft = (w + 30) + "px";
    });

    // 2) segmenter for hver linje (+ nullsymboler)
    lines.forEach((line, idx) => {
      const f = factors[idx];

      // nullsymboler
      f.roots.forEach(r => {
        const z = document.createElement("div");
        z.className = "zero-symbol";
        z.textContent = "0";
        z.style.left = pos(r) + "px";
        line.appendChild(z);
      });

      const ints = buildIntervals(allRoots);

      ints.forEach(I => {
        let s = 1;
        for (let i=0; i<f.roots.length; i++)
          s *= signFactor(I.sample, f.roots[i], f.mult[i]);

        const seg = document.createElement("div");
        seg.className = "factor-seg " + (s > 0 ? "posSeg" : "negSeg");

        const pad = 6;  // luft rundt 0

        let leftPos  = pos(I.left);
        let rightPos = pos(I.right);

        function isFactorRoot(x) {
          return f.roots.some(r => Math.abs(r - x) < 1e-9);
        }

        // Kun forkort ved ekte røtter for denne faktoren
        if (isFactorRoot(I.left))  leftPos  += pad;
        if (isFactorRoot(I.right)) rightPos -= pad;

        seg.style.left  = leftPos + "px";
        seg.style.width = (rightPos - leftPos) + "px";

        line.appendChild(seg);
      });
    });


// --- hvit stopper under produktlinja ---
const productLine = container.querySelector(".factor-line:last-child");

// --- automatisk rød boks under produktlinja ---
let red = container.querySelector("#red-box");
if (!red) {
  red = document.createElement("div");
  red.id = "red-box";
  container.appendChild(red);
}

const offset = -25;   // negativ verdi = opp, positiv = ned
red.style.top = (productLine.offsetTop + productLine.offsetHeight + offset) + "px";

const stopper = document.createElement("div");
stopper.className = "stopper";
// legg stopperen 5px under produktlinja
const y = productLine.offsetTop + productLine.offsetHeight + 5;
stopper.style.top = y + "px";
container.appendChild(stopper);

// --- helt ny, enkel, fungerende maskeringsblokk ---
let mask = container.querySelector("#bottom-mask");
if (!mask) {
  mask = document.createElement("div");
  mask.id = "bottom-mask";
  container.appendChild(mask);
}

mask.style.top = (productLine.offsetTop + productLine.offsetHeight + 5) + "px";

// 3) TEGN VERTIKALE LINJER TIL SLUTT (én gang)
drawVerticalLines(allRoots, container, pos);
``
    

    

  }); // <-- SLUTT på MathJax-blokken
} // <-- SLUTT på buildScheme(factors)
</script>

<script>
// =============================
// GENERER FRA INPUT
// =============================

function generateFromInput() {
  const txt = document.getElementById("inputPoly").value;
  if (!txt) return;

  const parsed = parsePolynomial(txt);
  if (parsed.length === 0) {
    alert("Kunne ikke tolke polynomet. Pass på at du skriver det faktorisert, f.eks (x-2)(2x+1).");
    return;
  }

  const factors = parsed.map(f => ({
    label: f.label,
    roots: [f.root],
    mult: [f.mult]
  }));

  // samlet produkt nederst
  factors.push({
    label: txt,
    roots: parsed.map(f => f.root),
    mult: parsed.map(f => f.mult)
  });

  buildScheme(factors);
}

// =============================
// EVENT-LISTENER
// =============================

document.getElementById("genBtn").addEventListener("click", generateFromInput);

// standard startverdi
document.getElementById("inputPoly").value =
  "(2x+1)(x-2)(x+3)";

generateFromInput();
</script>

</body>
</html>